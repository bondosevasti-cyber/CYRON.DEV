<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Fixed Invisible Wave</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #ffffff; 
        }
        canvas { 
            display: block; 
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>
</head>
<body>

<script type="module">
    import * as THREE from 'three';

    // 1. სცენა და კამერა
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xffffff); 
    scene.fog = new THREE.FogExp2(0xffffff, 0.015); // ნისლი

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    // კამერა დავწიოთ ცოტა დაბლა და ახლოს, რომ უკეთ გამოჩნდეს
    camera.position.set(0, 30, 50); 
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true; // ჩრდილების ჩართვა მოცულობისთვის
    document.body.appendChild(renderer.domElement);

    // განათება (რომ ნაწილაკები ბრტყელი არ იყოს)
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(10, 20, 10);
    scene.add(dirLight);

    // 2. იატაკი (Raycasting-ისთვის) - გავზარდოთ ზომა
    const planeGeometry = new THREE.PlaneGeometry(500, 500);
    const planeMaterial = new THREE.MeshBasicMaterial({ visible: false });
    const raycasterPlane = new THREE.Mesh(planeGeometry, planeMaterial);
    raycasterPlane.rotation.x = -Math.PI / 2;
    scene.add(raycasterPlane);

    // 3. ნაწილაკების სისტემა
    const count = 10000; // მეტი ნაწილაკი
    // ფორმა: კაფსულა/ტირე
    const geometry = new THREE.CapsuleGeometry(0.15, 1, 4, 8); 
    // ვატრიალებთ გეომეტრიას, რომ წოლით პოზიციაში იყოს თავიდან
    geometry.rotateX(Math.PI / 2);

    const material = new THREE.MeshPhongMaterial({ 
        color: 0x4285F4, 
        shininess: 100 
    });

    const mesh = new THREE.InstancedMesh(geometry, material, count);
    
    // მასივები
    const originalPositions = [];
    const randomPulse = [];
    
    const dummy = new THREE.Object3D();
    
    // ბადის გენერაცია (ზუსტი ცენტრირება)
    // კვადრატული ფესვი რაოდენობიდან, რომ გავიგოთ გვერდის ზომა
    const sideCount = Math.floor(Math.sqrt(count)); 
    const spacing = 1.2; // დაშორება
    const offset = (sideCount * spacing) / 2; // ცენტრირებისთვის

    let index = 0;
    for (let i = 0; i < sideCount; i++) {
        for (let j = 0; j < sideCount; j++) {
            
            // X და Z კოორდინატების გამოთვლა ისე, რომ 0,0 იყოს შუაში
            const x = (i * spacing) - offset;
            const z = (j * spacing) - offset;

            originalPositions.push({ x: x, y: 0, z: z });
            randomPulse.push(Math.random() * Math.PI * 2);

            // თავიდან ვაყენებთ პოზიციას
            dummy.position.set(x, 0, z);
            dummy.scale.set(0, 0, 0); // უხილავი
            dummy.updateMatrix();
            mesh.setMatrixAt(index, dummy.matrix);
            
            index++;
        }
    }
    scene.add(mesh);

    // 4. მაუსის ლოგიკა
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2(9999, 9999); // თავიდან ეკრანს გარეთ
    let intersectPoint = new THREE.Vector3(0, 0, 0);

    window.addEventListener('mousemove', (event) => {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    });

    // 5. ანიმაცია
    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);
        const time = clock.getElapsedTime();

        // ვიგებთ მაუსის პოზიციას
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObject(raycasterPlane);

        let isMouseActive = false;
        if (intersects.length > 0) {
            intersectPoint = intersects[0].point;
            isMouseActive = true;
        }

        // შესავალი ეფექტი: პირველი 3 წამი ტალღა თავისით გაივლის
        const introWave = Math.max(0, 3 - time); 

        for (let i = 0; i < index; i++) {
            const pos = originalPositions[i];
            
            // მანძილი მაუსამდე
            const dx = pos.x - intersectPoint.x;
            const dz = pos.z - intersectPoint.z;
            const dist = Math.sqrt(dx * dx + dz * dz);
            
            // ეფექტის რადიუსი
            const radius = 12;
            
            let scale = 0;
            let lift = 0;

            // ლოგიკა: ან მაუსია ახლოს, ან შესავალი ეფექტია
            if ((isMouseActive && dist < radius) || introWave > 0) {
                
                // შესავალი ეფექტის ლოგიკა (ცენტრიდან ტალღა)
                let introFactor = 0;
                if (introWave > 0) {
                     // მანძილი ცენტრიდან (0,0)
                     const distCenter = Math.sqrt(pos.x*pos.x + pos.z*pos.z);
                     // ტალღა რომელიც გადის ცენტრიდან გარეთ
                     const waveFront = (time * 20) % 80; 
                     if (Math.abs(distCenter - waveFront) < 10) {
                         introFactor = 1 - (Math.abs(distCenter - waveFront) / 10);
                     }
                }

                // მაუსის ეფექტის ლოგიკა
                let mouseFactor = 0;
                if (dist < radius) {
                    mouseFactor = 1 - (dist / radius);
                }

                // საბოლოო ძალა (რომელიც უფრო ძლიერია)
                const factor = Math.max(mouseFactor, introFactor);

                if (factor > 0) {
                    // სიმაღლე და სუნთქვა
                    const breathe = Math.sin(time * 4 + randomPulse[i]) * 0.2 + 1;
                    
                    scale = factor * breathe;
                    lift = factor * 8; // 8 ერთეულით ზევით

                    dummy.position.set(pos.x, lift, pos.z);
                    
                    // Z ღერძზე გაწელვა მოგრძო ეფექტისთვის
                    dummy.scale.set(scale, scale, scale * 2);
                    
                    // როტაცია: თუ მაუსია, მაუსს უყურონ. თუ ინტროა, ცენტრს.
                    if (mouseFactor > introFactor) {
                        dummy.lookAt(intersectPoint.x, lift + 2, intersectPoint.z);
                    } else {
                        dummy.lookAt(0, lift, 0);
                    }
                } else {
                    dummy.scale.set(0, 0, 0);
                }

            } else {
                dummy.scale.set(0, 0, 0);
            }

            // მხოლოდ მაშინ განვაახლოთ მატრიცა, თუ ნაწილაკი ჩანს (ოპტიმიზაცია)
            if (scale > 0.01) {
                dummy.updateMatrix();
                mesh.setMatrixAt(i, dummy.matrix);
            } else {
                 // თუ უხილავია, დავრწმუნდეთ რომ მატრიცაც 0-ია (წინა კადრიდან რომ არ დარჩეს)
                 dummy.scale.set(0,0,0);
                 dummy.updateMatrix();
                 mesh.setMatrixAt(i, dummy.matrix);
            }
        }

        mesh.instanceMatrix.needsUpdate = true;
        renderer.render(scene, camera);
    }

    // რესაიზი
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();

</script>
</body>
</html>